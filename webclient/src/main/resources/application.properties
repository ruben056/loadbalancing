spring.application.name=webclient
server.port=8079

eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
eureka.instance.hostname=localhost
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=true


# todo i put this property in api/eureka registry/client.
# i am not sure where it actually needs to go, but i doubt it has to go in all three...
# however it dit have the desired effect... the client eventually forgot about the api that was down
# and when it came back up, after a while it started using it again...
# for the time in between, retries = 2 and round robin loadbalancer is a good combination to always receive an answer
# as long as one api instance is running...
#
eureka.client.healthcheck.enabled=true

#By default, traffic is routed to upstream services, even if they are unhealthy. To prevent picking a bad one, you can enable the health-check configuration provided by the Load Balancer Client from Spring Cloud:
#however when u enable this, i get service unavailable all the time even when service is available...
# wss omdat er geen actuator is op de api services -> todo daar actuator toevoegen... (done)
# test met actuator op services enabled: nog altijd 503 service unavailable
#
# spring.cloud.loadbalancer.configurations=health-check


# dan zouden de serviceinstances telkens opnieuw opgehaald moeten worden
# dus zouden we sneller moeten detecteren dat een instance down is.
# -> werkt wel degelijk op die manier detectere we direct of een instance down of weer up is
# echter je moet wel telkens  opnieuw bij de eureka registry server de lijst van instances voor de service opvragen
# qua efficientie is dit wat minder... Daarom is het ook niet 'recommended' cfr de spring cloud docs...

#spring.cloud.loadbalancer.cache.enabled=false
#
# tussenweg, ipv cache disablen, spelen met de ttl van de cache (ttl op 5 seconden zetten ofzo ipv de default 35)
spring.cloud.loadbalancer.cache.ttl=5s

# alternatief proberen healtheck die periodiek de instances in onze list controleert
# zodat we geen request blijven sturen naar instances die down zijn, tot ze uit de cache zijn...
# you will detect down clients earlier, but it will take 1 a 2 minutes to detect they are up...
#
#spring.cloud.loadbalancer.health-check.refetch-instances-interval=5
